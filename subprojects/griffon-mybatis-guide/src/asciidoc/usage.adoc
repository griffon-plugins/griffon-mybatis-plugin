
[[_Usage]]
= Usage

The following sections describe how you may use this plugin in a project.

== Configuration

This plugin relies on the {link_griffon_datasource_plugin}. Please follow the instructions to configure this plugin first.

You must create a configuration file named `Mybatis` that holds the settings for creating instances of `{link_sql_session_factory}`.
This file follows the same standard configuration mechanism as the application's `Config` file, which means you can define the
configuration using

 * a properties file
 * a Java file
 * a Groovy script

The following example shows the default settings needed to connect the default database taking into account that each
environment may connect to a different database.

[source,groovy,options="nowrap"]
.src/main/resources/Mybatis.groovy
----
include::{path_griffon_mybatis_core}/src/test/resources/Mybatis.groovy[lines=16..37]
----

You may configure multiple named SqlSessionFactories (the default factory is aptly named `default`) as the following snippet
shows

[source,groovy,options="nowrap"]
.src/main/resources/Mybatis.groovy
----
include::{path_griffon_mybatis_core}/src/test/resources/Mybatis.groovy[lines=39..46]
----

The following properties are optional

[cols="4*",options="header"]
|===

| Property           | Type    | Default | Description
| connect_on_startup | boolean | false   | Establishes a connection to the datasource at the beginning of the `Startup` phase.
| jmx                | boolean | true    | Expose sessions using JMX.

|===

The plugin's <<_modules, module>> registers a `{api_mybatis_handler}` helper class that defines the base contract
for accessing a datasource and issue SQL queries to it. This class has the following methods

[source,java,options="nowrap"]
.griffon.plugins.mybatis.MybatisHandler.java
----
include::{path_griffon_mybatis_core}/src/main/java//griffon/plugins/mybatis/MybatisHandler.java[tags=methods,indent=0]
----

These methods are aware of multiple datasources. If no sessionFactoryName is specified when calling them then the default
datasource will be selected. You can inject an instance of this class anywhere it's needed using `@Inject`. There is one
callback you may use with this method: `{api_mybatis_callback}`.

This callback is defined using a functional interface approach, which means you can apply lambda expressions if running
with JDK8+ or closures if running Groovy.

[source,java,options="nowrap"]
.griffon.plugins.mybatis.MybatisCallback.java
----
include::{path_griffon_mybatis_core}/src/main/java/griffon/plugins/mybatis/MybatisCallback.java[lines=25..-1]
----

=== Mappers

MyBatis requires a mapper class for each type you'd like to map to a table. The plugin can automatically discover mappers
that should be added to a `{link_sql_session_factory}` as long as they are annotated with `@TypeProviderFor`. For example

[source,groovy,options="nowrap"]
.src/main/groovy/griffon/plugins/mybatis/mappers/PersonMapper.groovy
----
include::{path_griffon_mybatis_core}/src/test/groovy/griffon/plugins/mybatis/mappers/PersonMapper.groovy[lines=16..-1]
----

Don't forget mappers require a matching XML file that contains query definitions, such as

[source,xml,options="nowrap"]
[subs="verbatim,attributes"]
.src/main/resources/griffon/plugins/mybatis/mappers/PersonMapper.xml
----
include::{path_griffon_mybatis_core}/src/test/resources/griffon/plugins/mybatis/mappers/PersonMapper.xml[lines=19..-1]
----

=== Bootstrap

You may execute arbitrary database calls during connection and disconnection from a `{link_sql_session_factory}`. Simply
create a class that implements the `{api_mybatis_bootstrap}` interface and register it within a module, for example

[source,java,options="nowrap"]
.src/main/java/com/acme/SampleMybatisBootstrap.java
----
package com.acme;

import griffon.plugins.mybatis.MybatisBootstrap;
import org.apache.ibatis.session.SqlSession;

import javax.annotation.Nonnull;
import javax.inject.Named;

@Named("sample")
public class SampleMybatisBootstrap implements MybatisBootstrap {
    @Override
    public void init(@Nonnull String sessionFactoryName, @Nonnull SqlSession session) {
        // operations after first connection to datasource
    }

    @Override
    public void destroy(@Nonnull String sessionFactoryName, @Nonnull SqlSession session) {
        // operations before disconnecting from the datasource
    }
}
----

[source,java,options="nowrap"]
.src/main/java/com/acme/ApplicationModule.java
----
package com.acme;

import griffon.plugins.mybatis.MybatisBootstrap;
import griffon.core.injection.Module;
import org.codehaus.griffon.runtime.core.injection.AbstractModule;
import org.kordamp.jipsy.ServiceProviderFor;

@ServiceProviderFor(Module.class)
public class ApplicationModule extends AbstractModule {
    @Override
    protected void doConfigure() {
        bind(MybatisBootstrap.class)
            .to(SampleMybatisBootstrap.class)
            .asSingleton();
    }
}
----

== Example

The following is a trivial usage of the `{api_mybatis_handler}` inside a Java service

[source,java,options="nowrap"]
.com.acme.SampleService.java
----
package com.acme;

import griffon.core.artifact.GriffonService;
import griffon.metadata.ArtifactProviderFor;
import org.codehaus.griffon.runtime.core.artifact.AbstractGriffonService;

import griffon.plugins.mybatis.MybatisHandler;
import griffon.plugins.mybatis.MybatisCallback;
import org.apache.ibatis.session.SqlSession;

import com.acme.mappers.PersonMapper;

import javax.annotation.Nonnull;
import javax.inject.Inject;

@ArtifactProviderFor(GriffonService.class)
public class SampleService extends AbstractGriffonService {
    @Inject
    private MybatisHandler mybatisHandler;

    public String getPersonName(final int id) {
         return mybatisHandler.withSqlSession(new MybatisCallback<String>() {
             public String handle(@Nonnull String sessionFactoryName, @Nonnull SqlSession session) {
                 PersonMapper mapper = session.getMapper(PersonMapper.class);
                 Person person = mapper.findPersonById(id);
                 return person != null ? person.getName() : null;
         });
    }
}
----

Here's the Groovy version of it

[source,groovy,options="nowrap"]
.com.acme.SampleService.groovy
----
package com.acme

import griffon.core.artifact.GriffonService
import griffon.metadata.ArtifactProviderFor

import griffon.plugins.mybatis.MybatisHandler
import org.apache.ibatis.session.SqlSession

import com.acme.mappers.PersonMapper

import javax.inject.Inject

@ArtifactProviderFor(GriffonService)
class SampleService {
    @Inject
    private MybatisHandler mybatisHandler

    String getPersonName(int id) {
         mybatisHandler.withSqlSession { String sessionFactoryName, SqlSession session ->
             session.getMapper(PersonMapper)?.findPersonById(id)?.name
         }
    }
}
----

== Events

The following events will be triggered by `{api_mybatis_handler}`

MybatisConnectStart(String sessionFactoryName, Map<String, Object> config):: Triggered before connecting to the datasource.
MybatisConnectEnd(String sessionFactoryName, Map<String, Object> config, SqlSessionFactory factory):: Triggered after connecting to the datasource.
MybatisDisconnectStart(String sessionFactoryName, Map<String, Object> config, SqlSessionFactory factory):: Triggered before disconnecting from the datasource.
MybatisDisconnectEnd(String sessionFactoryName, Map<String, Object> config):: Triggered after disconnecting from the datasource.

NOTE: DataSource events may be triggered during connection and disconnection from a `{link_sql_session_factory}`.

== AST Transformation

You can apply the `{api_mybatis_aware}` AST transformation on any class. This injects the behavior of `{api_mybatis_handler}`
into said class. The previous Groovy service example can be rewritten as follows

[source,groovy,options="nowrap"]
.com.acme.SampleService.groovy
----
package com.acme

import griffon.core.artifact.GriffonService
import griffon.metadata.ArtifactProviderFor
import griffon.transform.MybatisAware

import org.apache.ibatis.session.SqlSession

import com.acme.mappers.PersonMapper

@MybatisAware
@ArtifactProviderFor(GriffonService)
class SampleService {
    String getPersonName(int id) {
         withSqlSession { String sessionFactoryName, SqlSession session ->
             session.getMapper(PersonMapper)?.findPersonById(id)?.name
         }
    }
}
----

== DSL Descriptors

This plugin provides DSL descriptors for Intellij IDEA and Eclipse (provided you have the Groovy Eclipse plugin installed).
These descriptors are found inside the `griffon-mybatis-groovy-compile-{project-version}.jar`, with locations

 * dsdl/griffon_mybatis.dsld
 * gdsl/griffon_mybatis.gdsl

== Transactions

The methods shown thus far all use the default behavior of AUTOCOMMIT = true.
This is fine is you are only reading data but, especially if you are modifying dependent rows in
different tables, you may need to use transaction. It is *VERY IMPORTANT* that transactions never span a
user interaction. To use transactions, you need to get a SqlSession with AUTOCOMMIT set to false. This session
will be then used to begin a new transaction, perform any inserts, deletes, updates, or even selects and finally
either commit or rollback the transaction. The session can (and probably should) then be closed.

The database work with transactions will usually all be done within a Griffon Service. The session can then be
held by the service. Since all Griffon Services are Singletons, you can be sure that there will be only one instance and thus only the one session. It is very important that all interactions with those table are
initiated by the same session since those SQL statements will create locks on rows that are modified (and
possibly additional rows). Those locks belong to the session and other sessions will either not see the changes
or wait for the Commit to occur. The difference depends on the database in use and the specific SQL statements.

The general pattern for this type of code is:

[source,groovy,options="nowrap"]
----
    @javax.inject.Inject
    private MybatisHandler handler

    private SqlSession currentSession = null

    void beginTransaction() {
        if (currentSession == null) {
            currentSession = handler.getSqlSession("default", false)
        }
    }
----

Other routines within the database service can then use that session:
[source,groovy,options="nowrap"]
----
public  int updatePerson(Person person) {
             PersonMapper mapper = currentSession.getMapper(PersonMapper.class);
             int updateCount = mapper.updatePerson(person)
             return updatePerson
         }
----

Finally the transaction should be either committed or rolled back:
[source,groovy,options="nowrap"]
----
    void commitWork() {
        if (currentSession == null) {
            throw new RuntimeException("Attempting to commit work when not in a transaction")
        }
        currentSession.commit()
        currentSession.close()
        currentSession = null
    }
----
The commit may close the session or leave it around for later use. If it is unused for very long, (especially if there is a user interaction involved)
it will automatically be closed.


Rollback would be similar except currentSession.rollback() would be used

The code using making use of the database service should enclose the service requests within a TRY, CATCH, FINALLY block to ensure that any errors cause the changes to be rolled back:
[source,groovy,options="nowrap"]
----
try {
    databaseService.beginTransaction()
....
    databaseService.commitWork()
}  catch (Exception exception) {
    databaseService.rollback()
}  finally {
    databaseService.closeSession()
}
----
