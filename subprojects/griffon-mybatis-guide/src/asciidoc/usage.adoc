
[[_Usage]]
= Usage

The following sections describe how you may use this plugin in an project.

== Configuration

You must create a configuration file named `Mybatis` that holds the settings for accessing the database. This file
follows the same standard configuration mechanism as the application's `Config` file, which means you can define the
configuration using

 * a properties file
 * a Java file
 * a Groovy script

The following example shows the default settings needed to connect to an H2 database taking into account that each
environment may connect to a different database.

[source,groovy,options="nowrap"]
.src/main/resources/Mybatis.groovy
----
include::{path_griffon_mybatis_core}/src/test/resources/Mybatis.groovy[lines=16..46]
----

You may configure multiple named datasources (the default mybatis is aplty named `default`) as the following snippet
shows

[source,groovy,options="nowrap"]
.src/main/resources/Mybatis.groovy
----
include::{path_griffon_mybatis_core}/src/test/resources/Mybatis.groovy[lines=48..63]
----

The plugin's <<_modules, module>> registers a `{api_mybatis_handler}` helper class that defines the base contract
for accessing a mybatis and issue SQL queries to it. This class has the following methods

[source,java,options="nowrap"]
.griffon.plugins.mybatis.MybatisHandler.java
----
include::{path_griffon_mybatis_core}/src/main/java//griffon/plugins/mybatis/MybatisHandler.java[tags=methods,indent=0]
----

These method are aware of multiple datasources. If no sessionFactoryName is specified when calling them then the default
mybatis will be selected. You can inject an instance of this class anywhere it's needed using `@Inject`. There are two
callbacks you may use with this methods: either you work with a `java.sql.Mybatis` instance using `{api_mybatis_callback}`
or with a `java.sql.Connection` instance using `{api_connection_callback}`. Both options will come in handy with other plugins
or APIs that require one instance or the other.

Both callbacks are defined using a functional interface approach, which means you can apply lambda expression if running
with JDK8+ or closures if running Groovy.

[source,java,options="nowrap"]
.griffon.plugins.mybatis.MybatisCallback.java
----
include::{path_griffon_mybatis_core}/src/main/java/griffon/plugins/mybatis/MybatisCallback.java[lines=25..-1]
----

[source,java,options="nowrap"]
.griffon.plugins.mybatis.ConnectionCallback.java
----
include::{path_griffon_mybatis_core}/src/main/java/griffon/plugins/mybatis/ConnectionCallback.java[lines=26..-1]
----

== Example

The following is a trivial usage of the `{api_mybatis_handler}` paired with http://jdbi.org[JDBI, window="_blank"]
inside a service

[source,java,options="nowrap"]
.com.acme.SampleService.java
----
package com.acme;

import griffon.core.artifact.GriffonService;
import griffon.metadata.ArtifactProviderFor;
import org.codehaus.griffon.runtime.core.artifact.AbstractGriffonService;

import griffon.plugins.mybatis.MybatisHandler;
import griffon.plugins.mybatis.MybatisCallback;
import javax.sql.Mybatis;
import java.sql.SQLException;

import org.skife.jdbi.v2.DBI;
import org.skife.jdbi.v2.Handle;
import org.skife.jdbi.v2.util.StringMapper;

import javax.annotation.Nonnull;
import javax.inject.Inject;

@ArtifactProviderFor(GriffonService.class)
public class SampleService extends AbstractGriffonService {
    @Inject
    private MybatisHandler mybatisHandler;

    public String getPersonName(final long id) {
         return mybatisHandler.withDataSoure(new MybatisCallback<String>() {
             public String handle(@Nonnull String sessionFactoryName, @Nonnull Mybatis mybatis)
                            throws SQLException
                 try(Handle h = new DBI(mybatis).open()) {
                    return h.createQuery("SELECT name FROM people WHERE id = :id")
                        .bind("id", id)
                        .map(StringMapper.FIRST)
                        .first();
                 }
         });
    }
}
----

== Events

The following events will be triggered by `{api_mybatis_handler}`

MybatisConnectStart(String sessionFactoryName, Map<String, Object> config):: Triggered before connecting to the mybatis.
MybatisConnectEnd(String sessionFactoryName, Map<String, Object> config, Mybatis mybatis):: Triggered after connecting to the mybatis.
MybatisDisconnectStart(String sessionFactoryName, Map<String, Object> config, Mybatis mybatis):: Triggered before disconnecting from the mybatis.
MybatisDisconnectEnd(String sessionFactoryName, Map<String, Object> config):: Triggered after disconnecting from the mybatis.

== AST Transformation

You can apply the `{api_mybatis_aware}` AST transformation on any class. This injects the behavior of `{api_mybatis_handler}`
into said class

== DSL Descriptors

This plugin provides DSL descriptors for Intellij IDEA and Eclipse (provided you have the Groovy Eclipse plugin installed).
These descriptors are found inside the `griffon-mybatis-groovy-compile-{project-version}.jar`, with locations

 * dsdl/griffon_mybatis.dsld
 * gdsl/griffon_mybatis.gdsl
